package com.salhack.summit.module.exploit;

import com.salhack.summit.events.MinecraftEvent.Stage;
import com.salhack.summit.events.bus.EventHandler;
import com.salhack.summit.events.bus.Listener;
import com.salhack.summit.events.player.EventPlayerMotionUpdate;
import com.salhack.summit.events.player.EventPlayerUpdate;
import com.salhack.summit.module.Module;
import com.salhack.summit.module.Value;
import com.salhack.summit.util.MathUtil;
import net.minecraft.block.state.IBlockState;
import net.minecraft.init.Blocks;
import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.util.math.BlockPos;

import java.util.Random;

public final class PacketFly extends Module
{
    public final Value<Boolean> AntiKick = new Value<>("AntiKick", new String[] {""}, "Prevents you from getting kicked while flying by vanilla anticheat", true);
    public final Value<String> Phase = new Value<>("Phase", new String[] {"Type"}, "Type of phase to use", "None");
    public final Value<String> Type = new Value<>("Type", new String[] {"Type"}, "Mode of packets to send to spoof the anticheat", "Preserve");
    public final Value<Float> Speed = new Value<>("Speed", new String[] {"S"}, "How fast packetfly should go", 0.25f, 0.1f, 1.0f, 0.1f);
    
    public PacketFly()
    {
        super("PacketFly", new String[]
        { "PacketFly" }, "Uses packets to fly", "NONE", 0xDB248A, ModuleType.EXPLOIT);
        
        Phase.addString("None");
        Phase.addString("Semi");
        Phase.addString("Full");
        Type.addString("Preserve");
        Type.addString("Up");
        Type.addString("Down");
    }
    
    private Random _random = new Random();
    public static int lastTeleportId = -1;
    private int ticksAntiKick = 0;
    private int ticksFlying = 0;
    private boolean shouldCancel = true;
    
    @Override
    public void onEnable()
    {
        super.onEnable();
        lastTeleportId = -1;
        shouldCancel = true;
    }
    
    @EventHandler
    private Listener<EventPlayerUpdate> onPlayerUpdate = new Listener<>(event ->
    {
        mc.player.setVelocity(0, 0, 0);
        
        if (!mc.player.onGround)
        {
            if (++ticksAntiKick >= 4)
            {
                ticksAntiKick = 0;
                mc.player.motionY = -0.04;
                shouldCancel = false;
            }
        }
        
        if (mc.player.movementInput.moveStrafe != 0f || mc.player.movementInput.moveForward != 0f)
        {
            double[] dir = MathUtil.directionSpeed(0.18);
            
            mc.player.motionX = dir[0];
            mc.player.motionZ = dir[1];
            shouldCancel = false;
        }
        else if (mc.player.movementInput.jump)
        {
            mc.player.motionY = 0.062;
            
            if (!mc.player.onGround && ++ticksFlying >= 20)
            {
                ticksFlying = 0;
                mc.player.motionY = -0.032;
            }
            
            shouldCancel = false;
        }
        
        double spoofX = mc.player.posX + mc.player.motionX;
        double spoofY = mc.player.posY + mc.player.motionY;
        double spoofZ = mc.player.posZ + mc.player.motionZ;
        
        switch (Type.getValue())
        {
            case "Down":
                spoofY -= 1337.69;
                break;
            case "Up":
                spoofY += 1337.69;
                break;
            case "Preserve":
                spoofX += _random.nextInt(100000);
                spoofZ += _random.nextInt(100000);
                break;
        }

        mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX + mc.player.motionX, mc.player.posY + mc.player.motionY, mc.player.posZ + mc.player.motionZ, mc.player.onGround));
        mc.player.connection.sendPacket(new CPacketPlayer.Position(spoofX, spoofY, spoofZ, mc.player.onGround));
        if (lastTeleportId != -1)
            mc.player.connection.sendPacket(new CPacketConfirmTeleport(lastTeleportId++));
    });
    
    @EventHandler
    private Listener<EventPlayerMotionUpdate> onMotionUpdate = new Listener<>(event ->
    {
        if (event.getStage() == Stage.Pre)
            if (shouldCancel)
                event.cancel();
    });
}
